<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Scroll Load More with Variable Width Items</title>
    <style>
      body {
        margin: 0;
        padding: 20px;
        font-family: sans-serif;
      }

      .scroll-container {
        display: flex;
        overflow-x: auto;
        gap: 10px;
        padding: 10px;
        border: 1px solid #ccc;
        height: 320px;
        align-items: center;
        position: relative;
      }

      .item {
        flex: 0 0 auto;
        min-width: 200px;
        max-width: 400px;
        height: 300px;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 18px;
        background: #f5f5f5;
        border: 1px solid #ccc;
        border-radius: 10px;
        padding: 10px;
        box-sizing: border-box;
      }

      .item.active {
        background-color: #007bff;
        color: white;
        font-weight: bold;
      }

      .loader {
        width: 40px;
        height: 40px;
        border: 4px solid #ccc;
        border-top: 4px solid #007bff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        flex: 0 0 auto;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>
  <body>
    <div id="container" class="scroll-container"></div>
    <button
      id="left-arrow"
      style="position: fixed; left: 10px; top: 50%; z-index: 10"
    >
      ←
    </button>
    <button
      id="right-arrow"
      style="position: fixed; right: 10px; top: 50%; z-index: 10"
    >
      →
    </button>

    <script>
      const container = document.getElementById("container");
      const totalItems = 100;
      const activeItem = 41;
      const visibleBefore = 10;
      const visibleAfter = 10;
      const loadedItems = new Set();
      let isLoading = false;
      let lastLoadDirection = null;

      function randomWidthContent(index) {
        const words = Array.from(
          { length: Math.floor(Math.random() * 20 + 5) },
          (_, i) => `Word${i}`
        ).join(" ");
        return `Item ${index}<br>${words}`;
      }

      function createItem(index) {
        const div = document.createElement("div");
        div.className = "item";
        div.innerHTML = randomWidthContent(index);
        div.dataset.index = index;
        if (index === activeItem) {
          div.classList.add("active");
        }
        return div;
      }

      function insertLoader(prepend) {
        const loader = document.createElement("div");
        loader.className = "loader";
        if (prepend) {
          container.prepend(loader);
        } else {
          container.appendChild(loader);
        }
        return loader;
      }

      async function loadItems(start, end, prepend = false) {
        if (isLoading) return;
        isLoading = true;

        const loader = insertLoader(prepend);
        const prevScrollLeft = container.scrollLeft;
        const prevScrollWidth = container.scrollWidth;

        await new Promise((resolve) => setTimeout(resolve, 1000));
        loader.remove();

        const items = [];
        for (let i = start; i <= end; i++) {
          if (i < 1 || i > totalItems || loadedItems.has(i)) continue;
          const el = createItem(i);
          items.push(el);
          loadedItems.add(i);
        }

        if (items.length === 0) {
          isLoading = false;
          return;
        }

        if (prepend) {
          items.reverse().forEach((el) => container.prepend(el));
          const scrollDiff = container.scrollWidth - prevScrollWidth;
          container.scrollLeft = prevScrollLeft + scrollDiff;
        } else {
          items.forEach((el) => container.appendChild(el));
        }

        isLoading = false;
      }

      async function initialize() {
        const from = activeItem - visibleBefore;
        const to = activeItem + visibleAfter;
        await loadItems(from, to);

        requestAnimationFrame(() => {
          const activeEl = container.querySelector(".item.active");
          if (activeEl) {
            const left = activeEl.offsetLeft;
            container.scrollTo({
              left: left - container.clientWidth / 2 + activeEl.offsetWidth / 2,
              behavior: "smooth",
            });
          }
        });
      }

      let debounceTimer = null;

      // Enable horizontal scroll with vertical mouse wheel
      container.addEventListener(
        "wheel",
        function (event) {
          if (event.deltaY !== 0) {
            event.preventDefault();
            container.scrollLeft += event.deltaY;
          }
        },
        { passive: false }
      );

      container.addEventListener("scroll", () => {
        if (isLoading) return;

        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => {
          const scrollLeft = container.scrollLeft;
          const scrollRight =
            container.scrollWidth - scrollLeft - container.clientWidth;

          const loadedIndexes = [...loadedItems];
          if (loadedIndexes.length === 0) return;

          const firstItem = Math.min(...loadedIndexes);
          const lastItem = Math.max(...loadedIndexes);

          if (
            scrollLeft < 100 &&
            lastLoadDirection !== "left" &&
            firstItem > 1
          ) {
            lastLoadDirection = "left";
            loadItems(firstItem - 10, firstItem - 1, true).then(() => {
              lastLoadDirection = null;
            });
          }

          if (
            scrollRight < 100 &&
            lastLoadDirection !== "right" &&
            lastItem < totalItems
          ) {
            lastLoadDirection = "right";
            loadItems(lastItem + 1, lastItem + 10, false).then(() => {
              lastLoadDirection = null;
            });
          }
        }, 100);
      });

      initialize();
    </script>

    <script>
      // ... [your existing code remains unchanged up to initialize()]

      function scrollToNextItem(direction = 1) {
        const items = [...container.querySelectorAll(".item")];
        const currentScroll = container.scrollLeft;
        const containerMid = currentScroll + container.clientWidth / 2;

        // Find the center item
        let centerIndex = items.findIndex((el) => {
          const elLeft = el.offsetLeft;
          const elRight = elLeft + el.offsetWidth;
          return elLeft <= containerMid && elRight >= containerMid;
        });

        if (centerIndex === -1) return;

        const targetIndex = centerIndex + direction;
        const target = items[targetIndex];
        if (!target) return;

        container.scrollTo({
          left:
            target.offsetLeft -
            container.clientWidth / 2 +
            target.offsetWidth / 2,
          behavior: "smooth",
        });
      }

      document.getElementById("left-arrow").addEventListener("click", () => {
        scrollToNextItem(-1);
      });

      document.getElementById("right-arrow").addEventListener("click", () => {
        scrollToNextItem(1);
      });

      // continue initializing after adding arrow logic
      initialize();
    </script>
  </body>
</html>
