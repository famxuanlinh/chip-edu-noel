<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Horizontal Scroll Load with Active Item</title>
    <style>
      body {
        margin: 0;
        padding: 20px;
        font-family: sans-serif;
      }

      .scroll-container {
        display: flex;
        overflow-x: auto;
        scroll-behavior: smooth;
        gap: 10px;
        padding: 10px;
        border: 1px solid #ccc;
        height: 320px;
        align-items: center;
        position: relative;
      }

      .item {
        flex: 0 0 auto;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #eee;
        border: 1px solid #999;
        border-radius: 8px;
        padding: 10px;
        font-size: 16px;
        height: 100px;
      }

      .item img {
        max-height: 100px;
        border-radius: 4px;
      }

      .item.active {
        background: #007bff;
        color: #fff;
        font-weight: bold;
      }

      .loader {
        width: 40px;
        height: 40px;
        border: 4px solid #ccc;
        border-top: 4px solid #007bff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        flex: 0 0 auto;
      }

      @keyframes spin {
        0% {
          transform: rotate(0);
        }
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>
  <body>
    <div id="container" class="scroll-container"></div>

    <script>
      const container = document.getElementById("container");
      const totalItems = 100;
      const activeItem = 54;
      const visibleBefore = 10;
      const visibleAfter = 10;
      const loadedItems = new Set();
      let isLoading = false;
      let lastLoadDirection = null;

      function createContent(index) {
        if (index % 5 === 0) {
          return `<img src="https://picsum.photos/200?random=${index}" alt="Image ${index}">`;
        } else if (index % 3 === 0) {
          return `Item ${index} with a really really really wide content that stretches far`;
        } else {
          return `Item ${index}`;
        }
      }

      function createItem(index) {
        const div = document.createElement("div");
        div.className = "item";
        div.innerHTML = createContent(index);
        div.dataset.index = index;
        if (index === activeItem) {
          div.classList.add("active");
        }
        return div;
      }

      function insertLoader(prepend) {
        const loader = document.createElement("div");
        loader.className = "loader";
        if (prepend) container.prepend(loader);
        else container.appendChild(loader);
        return loader;
      }

      async function loadItems(start, end, prepend = false) {
        if (isLoading) return;
        if (start > totalItems || end < 1) return;

        isLoading = true;
        const loader = insertLoader(prepend);
        const prevScrollLeft = container.scrollLeft;
        const prevScrollWidth = container.scrollWidth;

        await new Promise((resolve) => setTimeout(resolve, 1000));
        loader.remove();

        const items = [];
        for (let i = start; i <= end; i++) {
          if (i < 1 || i > totalItems || loadedItems.has(i)) continue;
          const el = createItem(i);
          items.push(el);
          loadedItems.add(i);
        }

        if (prepend) {
          items.reverse().forEach((el) => container.prepend(el));
          const scrollDiff = container.scrollWidth - prevScrollWidth;
          container.scrollLeft = prevScrollLeft + scrollDiff;
        } else {
          items.forEach((el) => container.appendChild(el));
        }

        isLoading = false;
      }

      async function initialize() {
        const from = Math.max(1, activeItem - visibleBefore);
        const to = Math.min(totalItems, activeItem + visibleAfter);
        await loadItems(from, to);

        requestAnimationFrame(() => {
          const activeEl = container.querySelector(".item.active");
          if (activeEl) {
            const left = activeEl.offsetLeft;
            container.scrollTo({
              left: left - container.clientWidth / 2 + activeEl.offsetWidth / 2,
              behavior: "smooth",
            });
          }
        });
      }

      let debounceTimer = null;

      container.addEventListener("scroll", () => {
        if (isLoading) return;

        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => {
          const scrollLeft = container.scrollLeft;
          const scrollRight =
            container.scrollWidth - scrollLeft - container.clientWidth;

          const firstItem = Math.min(...loadedItems);
          const lastItem = Math.max(...loadedItems);

          if (
            scrollLeft < 100 &&
            lastLoadDirection !== "left" &&
            firstItem > 1
          ) {
            lastLoadDirection = "left";
            loadItems(firstItem - 10, firstItem - 1, true).then(() => {
              lastLoadDirection = null;
            });
          }

          if (
            scrollRight < 100 &&
            lastLoadDirection !== "right" &&
            lastItem < totalItems
          ) {
            lastLoadDirection = "right";
            loadItems(lastItem + 1, lastItem + 10, false).then(() => {
              lastLoadDirection = null;
            });
          }
        }, 100);
      });

      initialize();
    </script>
  </body>
</html>
